<p data-ke-size="size16">&nbsp;.NET 6 supports C# language version 10. Among various improvements, there have been some
    enhancements to lambda expressions. Let's take a look.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">Original link: <a
        href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#explicit-return-type"
        target="_blank"
        rel="noopener">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#explicit-return-type</a>
</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size20"><h2>1. Natural type of a lambda expression</h2></p>
<p data-ke-size="size16">&nbsp;In the past, assigning a lambda expression to a variable with a var type would result in
    an error, requiring explicit type declaration with Func&lt;string, int&gt;. Now, the compiler is smart enough to
    infer the return type from the lambda expression.</p>
<br>
<pre id="code_1677808725470" class="sql" data-ke-language="sql"
    data-ke-type="codeblock"><code>var parse = (string s) =&gt; int.Parse(s);</code></pre>
<br>
<p data-ke-size="size16">This should have been possible a long time ago... It seems like Microsoft is not working hard
    enough.</p>
<p data-ke-size="size16">&nbsp;</p>
<br>
<p data-ke-size="size18"><h2>2. You can now specify the return type of a lambda expression.</h2></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">In the following lambda expression, the return type is ambiguous because it returns an int or a
    string based on the value of b, causing a compiler error. This often happens when multiple types need to be
    returned, and explicitly casting the return type can be cumbersome.</p>
<br>
<pre id="code_1677807045116" class="sql" data-ke-language="sql"
    data-ke-type="codeblock"><code>var choose = (bool b) =&gt; b ? 1 : "two"; // ERROR: Can't infer return type</code></pre>
<br>
<p data-ke-size="size16">Starting with C# 10, you can explicitly specify the return type in front of the lambda
    expression.</p>
<br>
<pre id="code_1677807053554" class="sql" data-ke-language="sql"
    data-ke-type="codeblock"><code>var choose = object (bool b) =&gt; b ? 1 : "two"; // Func&lt;bool, object&gt;</code></pre>
<br>
<p data-ke-size="size16">Personally, I wish the compiler would implicitly interpret such cases as object type without
    needing to explicitly write object. Sometimes C# feels a bit frustrating compared to other languages, but I hope
    many improvements will be made soon.</p>
<p data-ke-size="size16">&nbsp;</p>
<br>
<p data-ke-size="size18"><h2>3. Attributes</h2></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;You can now specify attributes for lambda expressions or their parameters. Personally, I
    have never felt the need to specify attributes for lambda expressions, but it's always good to have more
    flexibility...</p>
<p data-ke-size="size16">&nbsp;You can specify attributes for lambda expressions as shown below</p>
<br>
<pre id="code_1677809135308" class="angelscript" data-ke-language="sql"
    data-ke-type="codeblock"><code>Func&lt;string?, int?&gt; parse = [ProvidesNullCheck] (s) =&gt; (s is not null) ? int.Parse(s) : null;</code></pre>
<br>
<p data-ke-size="size16">&nbsp;You can also specify attributes for each parameter or for the return value as shown
    below.&nbsp;</p>
<br>
<pre id="code_1677809202818" class="sql" data-ke-language="sql" data-ke-type="codeblock"><code>var concat = ([DisallowNull] string a, [DisallowNull] string b) =&gt; a + b;
var inc = [return: NotNullifNotNull(nameof(s))] (int? s) =&gt; s.HasValue ? s++ : null;</code></pre>
<br>
<p data-ke-size="size16">&nbsp;</p>